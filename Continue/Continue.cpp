#include <locale.h>
#include <iostream>
using namespace std;

// Напишем программу, которая будет выводить на экран все нечетные числа, их количества и суммы от нуля до заданного числа. 

int main()
{
    setlocale(LC_ALL, "rus");
    cout << "-----------------------Программа вывода на экран всех нечетных чисел, их количества и суммы от нуля до заданного числа!--------------------------" << endl;
    int number = 0, count = 0, summa = 0;
    cout << "Введите число: "; cin >> number;

    // Нам нужно обработать все нечетные числа в цикле, а четные пропустить.

    for (int i = 1; i <= number; i++)       // мы перебераем все числа подряд (либо можно перебирать через одно i+=2) 
    {
        if (i % 2 == 0)continue;            // пропускаем все четные числа. А те, которые не пропускаем выводим на экран
        cout << i << "; ";                  // выводим нечетные числа на экран через ";"
        count++;                            // увеличиваем количество нечетных чисел (переменная увеличивается на 1 в блоке уже только нечетных чисел)
        summa += i;                         // подсчитаем сумму нечетных чисел и остается все вывести лишь на экран
    }
    cout << "\nКоличество нечетных чисел равно: " << count << endl;
    cout << "\nСумма нечетных чисел равна: " << summa << endl;

    /* Как это срабатывает? Когда компилятор обрабатывает continue, у нас пропускаются все действия, указанные после continue до закрывающейся фигурной скобки. Потом мы
    переходим в i++, увеличиваем счетчик, снова проверяем условие и заходим в цикл. Т.о. действия тела цикла будут пропущены через раз и будут выполнены только для не-
    четных чисел.

    Чем удобен continue в цикле for?
    В случае когда после сontinue все будет пропускаться компилятором, не нужно заботиться об изменении счетчика. Т.к. изменения счетчика прописаны в параметках цикла,
    то действия третьего блока будут выполнены в самом конце перед закрывающейся фиг.скобкой. А потом будет выполнена снова проверка условия и т.д.


    Разберем тонкости цикла:
    В блоках/параметрах цикла может не быть содержимое, а также может быть много содержимого. Мы можем инициализировать сразу несколько переменных в параметрах. Но тог-
    да они будут существовать только внутри цикла!
    Создадим цикл с двумя счетчиками:

    for (int i = 1, j = 0; i <= number && j != 0; i++, j++)
    Можно также сначала инициализировать i и j до цикла, а в цикле только присвоить им значения (без добавки типа данных внутри цикла как выше)

    Цикл for может содержать по одному действию в каждом блоке, может содержать по нескольку условий в каждом блоке, например комбинированное условие с оператором лог.
    объединения, а может не содержать в этих блоках ничего.
    Но и тело цикла тоже может быть пустым и программа будет работать. Т.к. третий блок выполняется прямо перед фиг.скобкой, это нам позволяет сделать цикл с пустым те-
    лом (крайне неэтично, но где-то встретить можно). Тело цикла будет пустым, а остальное перейдет в параметры:

    for (int i=1; i<=number; cout << i << "; ", count++, summa+=i, i+=2){} - цикл с пустым телом, все действия в блоках параметров

    Прежде чем увеличить счетчик, нам нужно вывести число на экран, в параметры мы это и напишем (все команды в параметрах разделяются запятыми, а блоки ";"), увеличи-
    ваем количество count, увеличиваем сумму на это число, а потом увеличиваем сам счетчик i+=2, чтобы пропустить все четные элементы.

    (!) Обязательно добавляем фиг.скобки в люб.цикл иначе он будет считать строчку ниже как тело цикла.
    Также если перепутать место скажем изменение счетчика ввести раньше чем подсчет суммы, то программа будет неправильно считать, будет сначала увеличивать счетчик, а
    потом вычислять сумму. Порядок важен! */
}