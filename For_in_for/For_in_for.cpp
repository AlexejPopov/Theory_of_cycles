#include <iostream>
#include <stdlib.h>
#include <windows.h>
using namespace std;

/* Рассмотрим возможность создания вложенных циклов for внутри for. Вложенная конструкция очень уобно помогает решает задачи где нужно несколько раз повторить несколько
повторений! Рассмотрим на примере программы подсчета упражнений в спортзале. */

int main()
{
    system("chcp 1251");
    system("cls");
    cout << "---------------------------------------------------Программа для подсчета количества упражнений!-------------------------------------------------" << endl;
    int podchod = 0, povtor = 0;
    cout << "Введите количество подходов: "; cin >> podchod;
    cout << "Введите количество повторений: "; cin >> povtor;

    for (int i = 1; i <= podchod; i++)                  // цикл подходов
    {
        cout << "Подход No " << i << endl;
        for (int j = 0; j <= povtor; j++)               // цикл повторов (счетчики д/б разные)
        {
            cout << "Выполнено " << j << " повторений, осталось " << povtor - j << " повторений!" << endl;
        }
        if (i != podchod)                                 // отдохнуть (между подходами). После последнего подхода отдыха нет.
        {
            cout << "Подход No " << i << " закончен! Перерыв 2 секунды!" << endl;
            Sleep(2000);
        }
    }
    cout << "Упражнение выполнено" << endl;

    /* Принцип действия:
   Когда мы заходим во внешний цикл, первоначальное значение счетчика = 1, запускается внутренний цикл и внутренний цикл выполняется полностью. Как только внутренний
   цикл выполнился полностью, мы выполняем оставшиеся действия внешнего цикла и возвращаемся в начало, увеличиваем счетчик внешнего цикла, снова проверяем условие внеш-
   него цикла, заходим во внутренний цикл и снова выполняем его полностью. Т.е. у нас внутренний цикл выполнится столько раз, сколько у нас шагов во внешнем цикле. */

    system("pause");
    system("cls");

    // Таблица умножения!

    for (int i = 1; i < 10; i++)                        // цикл прохода по строкам (вертикально)
    {
        for (int j = 1; j < 10; j++)                    // цикл заполнения строк (горизонтально)
        {
            cout << i * j << "\t";
        }                                               // табуляция и перенос строки превращают вывод данных в таблицу
        cout << endl;
    }

    /* Получается внешний цикл for (с i) строит таблицу по вертикали, а внутренний for (с j), по горизонтали. Но это не потому что в i запрограммированно по вертикали,
    а в j по горизонтали, нет. Все дело в том, что во внешнем цикле мы переводим строку вниз, а во внутреннем отодвигаемся табуляцией. И так как у нас внешний цикл пов-
    торится лишь тогда, когда полностью отыграет внутренний, а именно отработает все сдвиги табуляцией вправо, то и след, мы перейдем на новую строчку лишь тогда, когда
    я горизонталь уже будет заполнена!

    Внешним циклом мы, по сути, только переводим строку и прокручиваем внутренний цикл столько раз, сколько нам нужно, опуская его постоянно на строчку ниже. А внутрен-
    ний, в свою очередь, с каждым повторением внешнего цикла, вырисовывает нам всю строку через табуляцию горизонтально, перемножая i на j, заполняя тем самым все поле.

    Т.к. у нас консоль (это текстовый интерфейс), мы выводим на экран построчно, слева направо, а внутри строки выводим символ за символом, след, и представлять внешний
    вид нашей консольной программы мы можем в виде текста. И чтобы упорядочить внешний вид нашей программы, и сделать ее более наглядной нам нужен табличный вывод, с
    которым поможет вложенный цикл for, где внешний цикл for сдвигает вертикально вниз, а вложенный цикл for прорабатывает содержимое внутри строки (или по столбцам от-
    носительно размещения элементов). А перевод строки делает весь вид табличным, но при этом перевод строки должен быть лишь после вложенного цикла, иначе таблица не
    получится.

    Псевдографика
    Т.к. в прошлом графического интерфейса у операционной системы не было, работали все в консоли с зелеными цифрами, в которой еще было ограниченное число кодировок, а
    след, и ограниченное число символов. Но даже уже с помощью имеющихся символов м/б визуально оформлять программы для пользователя, а именно делать псевдографику.
    Псевдографика - это совокупность обычных символов, включенных в набор символов кодовой страницы, отображающие графические приметивы.

    Яркий пример псевдографики это смайлики, т.к. за красивой оболочкой скрывается код изображения: ;)  :Р  :) и др. А т.к. лат.буквы и основные символы есть в каждой
    кодировке, след, есть универсальность псевдографики, а именно их единый код в каждой кодировке. Изначально псевдографика была из самых простых символов типа $,?...,
    а позже для псевдографики появились спец.символы (закрашенные, с двумя черточками, уголками,...). Когда мы работаем в консоли у нас есть только символы чтобы как-то
    наглядно представить содержимое для пользователя, а самый наглядный вариант консоли это таблица. Далее псевдографику с данными можно сохранить в файл, т.к. файл это
    тоже набор символов (если мы работаем в текстовом режиме), а дальше отправить на печать и т.д.

    Изначально псевдографика разрабатывалась для консоли, а позже появились смайлики и даже картинки из символов. Чтобы сделать картинку из символов нужно указать номер
    строчки и номер столбца, в которые мы поместим символ. Объект картинки сделан из разных символов, а фон это не пустота, а ПРОБЕЛ. Наша програма заполняет всю табли-
    цу символами, в некоторых местах ставит определенные символы, а в остальных пробелы, тем самым получая таблицу. В нашей программе есть i и j. i это счетчик строчки
    (по-вертикали), а j это счетчик столбца (по-горизонтали). i и j называют индексы, определяющие адрес ячейки по строке и столбцу. Чтобы поставить на картинке какую-
    то '@' или еще что, нужно определиться с адресом нужной ячейки по строке и столбцу. Сверху идет первая строка, потом вторая строка... Во вторую строку поставим в 37
    столбец символ '@' (i=2, j=37). Вот так и начиналось рождение нашей всей графики, первых игр, мультимедии, меню, интерфейсов.

    P.S. На другой картинке с пандой, черное это пробелы.
    Но даже такой ввод символов можно оптимизировать, например, линию из одинаковых '@' задать в цикле. Правда скругленные детали или же одиночные символы вводятся
    вручную. Обязательно не забывать о фоне! Символы превратятся в картинку только в том случае если они будут в нужном месте относительно фона. Т.о. псевдографика это
    работа с ТАБЛИЦАМИ где есть строки и столбцы, а мы лишь формулируем условие, в какие ячейки этой таблицы поместить какие символы. Таблицы, оказывается, окружают нас
    везде и всюду! До сих пор все текстовые файлы табличного образца (двумерные) и они вокруг программиста чаще даже чем мы думаем. */
}